---
title: 从技术负责人角度谈IT产品管理
date: 2018-07-13 07:27:19
tags: 带团队
---


作为一款IT产品的技术负责人，工作上会有一些挑战，本文整理一下我本人工作经历过程中实践下来的一些经验，毕竟每个人面对的场景不一样，所以仅供大家参考。

### 团队

我对优秀团队的定义：自驱动

一款优秀的产品背后，一定有一个优秀的团队；优秀的团队也是需要花时间去磨合和成长的，不可能一伙陌生人一拍即合；在团队上，我更喜欢小而精的团队；团队成员的工作观是第一位的，有些人工作就是为了做一些有意义的事情，让世界更美好；有些人工作就是为了养家糊口；具备崇高价值观的人，更容易组建成为自驱动型团队。

![草帽海贼团](https://gitee.com/hongkaiwen/images/raw/master/blog/%E4%BB%8E%E6%8A%80%E6%9C%AF%E8%B4%9F%E8%B4%A3%E4%BA%BA%E8%A7%92%E5%BA%A6%E8%B0%88IT%E4%BA%A7%E5%93%81%E7%AE%A1%E7%90%86/%E8%8D%89%E5%B8%BD.jpeg)

#### 团队组建

团队组建之前，要结合团队要做的事情，兼顾长远目标，考虑下人员能力配比，说白了，要几个人、几个架构、几个高级、几个初级...

团队成员进来无非两个渠道：

- 内部转岗
- 外部招聘

作为负责人，无论从那面来的人，一定要面试，严把入口，不要因为项目紧就放宽对人的要求。

**成员怎么选**

上面说进人要严格把关，那需要怎么把关呢？面试的时候我有过一段时间的误区，**唯技术论**，好多候选人被虐的很惨。当然，每个人对优秀的人都有自己的定义，三观相符、技术过硬当然最好，但有时候考虑实际情况，可以考虑价值观放在第一位、然后是技术做一些基本要求，不要太吹毛求疵。总之，一个人面下来，尽量找他的优点，如果聊下来，你觉得你很想和他一起工作，那一定是最合适的。

#### 团队建设

团队成员逐渐加入，接下来就是团队建设。

- 明确团队的目标、描绘一个蓝图，鼓励大家把自己的目标和团队的目标结合起来
- 明确规章制度、团队尽量简单高效，少一些条条框框，但是总归有一些底线，比如无论任何时候，没有任何理由写烂代码
- 说道做到，赏罚分明
- 努力工作、开心生活（原来公司大佬的座右铭）

### 基础设施

上面扯了一下团队，表面上和产品管理没多大关系，但其实是产品的基石。接下来聊一下基础设施，IT产的开发过程中需要依赖一些IT基础设施：

- 任务跟踪： 常用的redmine、jira还有腾讯出的tapd，用来做任务管理，都挺好用的，如果从零开始有的选，目前建议 [tapd](https://www.tapd.cn/)。

- 代码仓库：svn、git，这个没什么好说的，现在都是git了吧。

- nexus： 主要用来deploy一些自己开发的类库，方便一些。

- 公共类库包：部署一些公共的类库，这一块说一下，公共包不要搞的很重，越简单越好，不要重复造轮子。如果有一些自研组件的sdk包，请记得做好版本管理，搞清楚snapshot和release版本个区别，设定好版本迭代的节奏。另外请维护好类似下面的文档

  | 版本号  | 版本说明    | 是否兼容 | 发布日期      | 发布人  |
  | ---- | ------- | ---- | --------- | ---- |
  | v1.1 | 0000001 | 是    | 2018-7-13 | xxx  |

  如果不向前兼容，请在另外维护一个文档说明一下升级方法。这块深入还有一些东西要展开，后面另开一篇文章来说。总之，公共类库包、是一把双刃剑、东西是好，但一定做好管理，尤其团队内实行了分布式系统架构。

- 知识库： 这个redmine也可以做、confluence也可以做。

### 版本管理

产品的版本管理很有必要，你是否遇见过如下问题：

- 当前版本开发到一半，上一个版本出了紧急bug需要修复或出现紧急需求需要立刻做
- 版本发布过程中，资深的成员比较高效，在当前的版本上没事可做，做下一个版本的功能的代码又不能提交
- 我们的代码部署到很多客户现场、某一个现场需要从1.3升级到当前最新的1.9版本，怎么升？脚本有哪些？
- 我们维护好了脚本，每一个版本都需要维护增量和全量两套脚本，可是有时候还是会出错，时间久远的版本的脚本总是感觉心里没底。

#### 代码版本

代码版本可以借鉴gitflow的发布方式，但是也要考虑自己的实际情况，比如我们团队就对gitflow做了一个简化，大体的流程简化为：

![simple git flow](https://gitee.com/hongkaiwen/images/raw/master/blog/%E4%BB%8E%E6%8A%80%E6%9C%AF%E8%B4%9F%E8%B4%A3%E4%BA%BA%E8%A7%92%E5%BA%A6%E8%B0%88IT%E4%BA%A7%E5%93%81%E7%AE%A1%E7%90%86/simple-git-flow.jpg)

**正常的开发流程**

- 所有的开发人员基于develop开发（如果按照git flow每一个新功能都自己拉一个分支，对于有些项目代价比较大，比如我们项目依赖各种组件，本地比较难以测试，都需要发布到线上去做集成测试，那如果每一个功能拉一个分支，成本会比较高）
- 在发版本之前，会基于develop分支拉一个release分支，然后基于release分支发布一个测试版本用来做发布前的最后一轮测试
- release分支拉好之后，当前版本没任务的人就可以在develop分支上开发下一个版本的任务
- 如果release分支有bug发生，则再release分支修复
- release分支测试完成后，基于release分支进行发布，发布完成确认没问题，把release分支merge回develop分支和master分支并打上该版本的tag

**紧急版本的发布流程**

因为每一个版本发布后会留下一个tag和对应的release分支，我们的tag一般是一个备份，紧急修复或紧急的新功能我们一般会基于目标版本的release分支来做。发布完成后release分支就不会在有提交。

- 基于release分支拉一个hotfix分支
- 在hotfix分支上做bug修复或紧急功能开发
- hotfix分支会升版本号，与原来的版本做区分
- hotfix分支开发完后基于hotfix分支做发布
- 发布完成后hotfix分支会合并或develop分支和master分支并打tag

**版本的输出**

我们对程序做了docker化 ([如何docker化](https://hongkaiwen.gitee.io/kuzan/2018/07/15/dockerize%20a%20spring%20boot%20project/))，所以每一个版本的输出产物是一个docker镜像，镜像的tag和程序的版本一致，这样一来，开发环境测试ok的镜像，我们会直接推送到镜像仓库，发布正式环境也是基于相同的镜像。这也依赖于代码中的配置需要做外部化，保证不同环境可以使用相同的镜像。

#### 数据库版本

数据库版本是个大事情，我们引入了flyway来做，数据库脚本也是源码和版本的一部分；数据库脚本的问题一样会记为bug。这样无论是做版本升级还是初次的版本部署，理想情况下我们提供的就是一个版本的镜像包，不需要额外的脚本，对部署人员很友好。我们也不是一开始就引入了flyway工具，针对半路开始使用的场景，也有方案可以进行无缝切换，无非是在开始集成的版本依然会跟没集成之前一样，有一个增量脚本，然后后续的版本就不在需要数据库脚本。详细的使用方法后续会在输出另外一个文章进行描述。另外提一句，flyway的脚本文件名需要提前规划好规则，大家按照规范来做，保证脚本的执行顺序和可追溯，比如我们的脚本名里会有tapd的号。

### 几个文档

- **运维相关 - 问题处理记录**

  对于线上运行中的环境，开发人员有时候需要进行技术支持，我们要求开发人员对每一次支持做记录，包括如下方面的内容：

  - 时间
  - 问题提出方： 项目、人员
  - 问题现象
  - 问题类型： bug、功能不清晰
  - 问题解决方案： 临时方案、最终方案
  - 问题跟踪： tapd连接、wiki文档

  所有的问题最终会归为两类bug或功能不清晰，针对bug，如果有临时可以绕过去的方案，我们会优先保证用户方的使用，提供临时的绕过去的方法，并后续对bug进行修复，但无论怎样，会在问题跟踪上记录一个bug记录，并把记录的连接贴在文档里。如果是功能使用的问题，短期我们会完善用户手册，长远看，我们会和产品经理进行讨论，通过功能设计规避用户的使用问题。

- **发布相关 - 发布说明文档、release note**

  发布相关的文档我们会整理两篇：

  - 发布说明文档：前面提过，我们的项目进行了docker化，所以发布比较简单，考虑发布的动作不一定开发人员做，而且有时发布的动作会有不同的人员来做；为了减少发布时出错的概率，减少发布时的沟通成本，我们会整理一个发布说明文档，包括一下信息：

    - 版本发布的基本信息：版本号、发布事件
    - 发布负责人
    - 特别说明： 操作系统特殊配置等
    - 增量脚本：虽然我们引入了flyway，但是考虑有些场景会需要，依然保留了这一项。
    - 镜像信息： 镜像名、镜像id
    - 启动命令、启动参数，相对于上一个版本变动的地方会做特殊标记

    同时对运维提出要求，除非是首发，一旦发布不成功，开发人员必须重新提供新版本的镜像；拒绝接受开发人员提供的临时脚本。保证运维人员去其他地方部署，照着当前的文档一定是可以部署成功的，所以部署人员接受到的所有的信息强制要求维护在部署说明文档里。

  - release note： 记录当前版本的变动信息，包括新功能和bug；版本的其他基本信息。

- **现场发布相关 - 部署记录**

  因为我们的产品会多地部署，部署出去的程序会做一个记录，方便支持：

  - 部署地点
  - 部署时间
  - 部署操作人
  - 部署版本
  - 备注

- **用户使用相关 - 用户手册**

  用户手册，包括按照场景的说明和faq的整理。这一块有些人整理用户手册喜欢按功能点来做，这种我不喜欢，因为这样会把用户的使用场景撕裂，用户接触的的都是零散的信息；我们会按照使用场景进行整理，比如标题一般类似：如何在前端项目中使用配置中心。

### 流程规范

- **任务完成标准**
  - 代码完成
  - 自测完成
  - 文档完成
    - 功能说明性文档
    - 部署相关的脚本
  - 任务跟踪系统中状态更新完成


- **发布流程**

  **首发**

  发布流程承接版本管理流程，每一个版本会指定一个版本发布负责人，负责 **把源码变成可发布的版本** 会承担程序首发时的所有工作，工作完成后会输出如下几项：

  - 镜像
  - 发布说明文档
  - release note文档
  - 版本tag
  - 分支merge完成
  - 版本发布通知邮件

  **二次发布**

  有发布操作人员照着发布说明文档进行发布。

- **开发节奏**

  开发节奏也与代码的版本管理有关，分支管理规范会对正常版本或hotfix版本产生流程约束；另外，还要引入codereview机制，尤其是在团队组建初期，要更加细致的进行codereview，树立团队成员的规范意识。我们的codereview是在每个版本做最终测试之前，所有的成员把当前版本的做的所有的任务，简单说一下：

  - 背景
  - 修改思路
  - 修改的代码

  这样，一来有些的不合理的地方，大家会进行提问，二来大家对每个人做的事情也有了一个大概的了解。当然这样做成本比较大，比较耗时。当团队磨合成熟之后，建议代码提交前相互review一下就好。如果版本里有一些比较大的改动，再召集集体review。

- **发布负责人制度**

  如**发布流程**里所讲，发布负责人在首发时负责很多工作，我们一般轮流做发布负责人，负责人最终输出的产物包括文档，其实可以理解为产品的一部分；发布负责人会对他负责的版本全权负责，如果第二次去客户现场部署时出了问题，发布负责人也是第一接口人。

  另外发布负责人制度避免开发人员**陪加班**的现象，版本发布时只有一个发布负责人在场加班即可，其他人可以按时下班，当然出了问题相关开发人员必须及时响应。

  发布负责人制度也让团队更高效，版本的release分支拉完，其他人就可以继续下一个版本的开发。

- **bug 处理机制**

  bug出现之后，我们会第一优先级介入，如果是可以绕过去的bug，会提供临时的解决方案给用户；如果是无关痛痒的bug，会在下一个版本修复；只要是影响了用户主流程的bug，我们会立即进行紧急版本的开发。

  另外bug修复不仅仅是修复代码，会要求相关开发人员提供bug的简单分析报告，分析bug产生的原因。

- **checklist制度**

  定期复盘，对于常犯的错误，整理成checklist，避免大家在同一个问题上犯两次错误，也不允许在同一个问题上犯两次错误。

### 结束语

上面都是一些方法论的东西，好多都是跟我的老领导那里学来的，有一些也是我自己总结的，在我目前带的团队里，按照这套流程来做，大家还是比较高效的，可以处理我们产品里遇到的各种场景的问题。

另外关于团队成员这一块，上面的方法论，如果有人有很高的执行力，并且在以下方面做的很好，我觉得就可以考虑作为核心成员来发展：

- 懂得总结思考，对流程提出可行的改进意见
- 技术过硬的同时，深刻理解产品业务，对功能上有自己的看法
- 无论是技术上、产品上、流程上坚持做正确的事

对于一个优秀的团队，我的定义是：自驱动

对于一个优秀的老大，我的定义是： 可以让一个团队，happy的、高效的完成既定的任务

我想这是**领导力**体现，也是**领导力**的结果吧。

如果团队成员在这种环境下，持续成长，当有一天，没有上升空间了，我觉得他离开，到别的团队发光发热，也是老大引以为豪的一键事情吧。

扯远了，就到这吧。